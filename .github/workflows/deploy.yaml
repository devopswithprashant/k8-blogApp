name: 'Deploy'

on:
  push:
    paths:
      - 'apps/**' 
  pull_request:



permissions:
  contents: read
  id-token: write # <--- REQUIRED for OIDC


concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: false


jobs:
  Deploy-K8:
    name: 'Deploy-K8'
    runs-on: ubuntu-latest

    # Use the Bash shell regardless whether the GitHub Actions runner is ubuntu-latest, macos-latest, or windows-latest
    defaults:
      run:
        shell: bash
    steps:

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v5
        with:
          aws-region: us-east-1
          role-session-name: GitHubActionsTerraform
          role-to-assume: ${{ secrets.AWS_SSM_ROLE }}

      - name: Checkout
        uses: actions/checkout@v4
        with:
            fetch-depth: 10
      
      - name: Determine before/after SHAs
        id: shas
        run: |
          set -euo pipefail
          BEFORE=${{ github.event.before }}
          AFTER=${{ github.sha }}

          # Ensure changed.txt exists (empty if none)
          : > changed.txt

          if [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
            # branch created or first commit — list files in the AFTER commit
            git diff --name-only "${AFTER}" > changed.txt || true
          else
            git diff --name-only "${BEFORE}" "${AFTER}" > changed.txt || true
          fi

          echo "Changed files (raw):"
          sed -n '1,200p' changed.txt || true

          # write to step output using GITHUB_OUTPUT
          CHANGED_RAW=$(sed -z 's/\n/|/g' changed.txt || true)
          echo "files=${CHANGED_RAW}" >> "$GITHUB_OUTPUT"

          # create file even if grep finds nothing
          : > files_under_apps.txt

          # Filter only relevant files under apps/ into files_under_apps.txt (no failure if none)
          grep -E '^apps/' changed.txt > files_under_apps.txt || true

          # Debug
          echo "Files under apps/:"
          sed -n '1,200p' files_under_apps.txt || true

          # If you want dirs up to apps/<team>/<app>/overlays/<env>,
          # that's first 5 path segments: apps/team/app/overlays/env
          # Adjust the awk field count if your layout is different.
          : > changed_dirs.txt
          awk -F'/' 'NF >= 5 { print $1"/"$2"/"$3"/"$4"/"$5 } NF < 5 { if (NF>0) print $0 }' files_under_apps.txt \
            | sort -u > changed_dirs.txt || true

          # produce comma-separated list and JSON array
          if [ -s changed_dirs.txt ]; then
            CSV=$(paste -sd, changed_dirs.txt)
            # Create JSON array using jq (one item per line)
            JSON_ARR=$(jq -R -s -c 'split("\n")[:-1]' changed_dirs.txt)
          else
            CSV=""
            JSON_ARR="[]"
          fi

          echo "dirs_csv=${CSV}" >> "$GITHUB_OUTPUT"
          echo "dirs_json=${JSON_ARR}" >> "$GITHUB_OUTPUT"
          # also export for later steps (optional)

          rootDir=$(echo $CSV | cut -d / -f 1)
          appName=$(echo $CSV | cut -d / -f 2)
          envName=$(echo $CSV | cut -d / -f 3)

          if [[ $appName != "blog" ]]; then
            echo "Not able to find change in correct app, invalid appName $appName"
            echo "exiting..."
            exit 1;
          fi
          echo "appName = $appName"

          if [[ $envName != "dev" ]] || [[ $envName != "qa" ]] || [[ $envName != "stage" ]] || [[ $envName != "prod" ]]; then
            echo "Not able to find change in correct env, invalid envName $envName"
            echo "exiting..."
            exit 1;
          fi

          echo "appName = $envName"
          
          if [[ $envName == prod ]] && [[ ${{ github.ref_name }} != 'refs/heads/main' ]]; then
            echo "Cannot deploy prod changes in non-default branch"
            echo "exiting..."
            exit 1;
          fi
          echo "changeDir=apps/${appName}/${envName}" >> $GITHUB_ENV

      - name: AWS Send Command
        run: |
          if [[ -z "${changeDir}" ]]; then
            echo "ChangeDir variable cannot be empty in order to proceed with deployment"
            echo "exiting..."
            exit 1;
          fi
          COMMAND_ID=$(aws ssm send-command \
            --document-name "K8SDeployer" \
            --comment "K8 Deployment from GitHub Actions" \
            --targets Key=tag:Name,Values=eks-bastion-blogapp \
            --parameters awsRegion=us-east-1,clusterName=blogapp-cluster,manifestDirectory=$changeDir \
            --region us-east-1 \
            --query "Command.CommandId" \
            --output text)

          echo "Command sent. Command ID: $COMMAND_ID"
          
          echo "Waiting for command to complete..."

          STATUS="InProgress"

          # Poll until the status changes to success/failed/etc.
          while [[ "$STATUS" == "InProgress" || "$STATUS" == "Pending" ]]; do
            sleep 5
            STATUS=$(aws ssm list-command-invocations \
              --command-id "$COMMAND_ID" \
              --details \
              --query "CommandInvocations[0].Status" \
              --output text)
            echo "Current status: $STATUS"
          done

          echo "-------------------------------------"
          echo "Command completed with status: $STATUS"
          echo "-------------------------------------"

          # Fetch logs (we will store them for clarity)
          STDOUT=$(aws ssm list-command-invocations \
            --command-id "$COMMAND_ID" \
            --details \
            --query "CommandInvocations[0].CommandPlugins[0].Output" \
            --output text)

          STDERR=$(aws ssm list-command-invocations \
            --command-id "$COMMAND_ID" \
            --details \
            --query "CommandInvocations[0].CommandPlugins[0].ResponseCode" \
            --output text)

          echo "------ OUTPUT LOG ------"
          echo "$STDOUT"
          echo "------------------------"

          # If status is NOT success → Exit with error
          if [[ "$STATUS" != "Success" ]]; then
            echo "❌ Deployment Failed!"
            echo "------ ERROR CODE ------"
            echo "$STDERR"
            echo "------------------------"
            exit 1
          fi

          echo "✅ Deployment completed successfully!"
            
            
